Hash table Wikipedia Hash table From Wikipedia free encyclopedia Jump navigation Jump search Not be confused with Hash list Hash tree Rehash redirects here South Park episode see Rehash South Park IRC command see List Internet Relay Chat commands REHASH Associates data values with key values lookup table Hash table Type Unordered associative array Invented Time complexity in big O notation Algorithm Average Worst case Space O n O n Search O O n Insert O O n Delete O O n small phone book as hash table In computing hash table hash map data structure that implements an associative array abstract data type structure that can map keys values hash table uses hash function compute an index also called hash code into an array buckets slots from which desired value can be found Ideally hash function will assign each key unique bucket but most hash table designs employ an imperfect hash function which might cause hash collisions hash function generates same index more than one key Such collisions must be accommodated in some way In well dimensioned hash table average cost number instructions each lookup independent number elements stored in table Many hash table designs also allow arbitrary insertions deletions key value pairs at amortized constant average cost per operation In many situations hash tables turn out be on average more efficient than search trees any other table lookup structure this reason they are widely used in many kinds computer software particularly associative arrays database indexing caches sets Contents Hashing Choosing hash function Perfect hash function Key statistics Collision resolution Separate chaining Separate chaining with linked lists Separate chaining with list head cells Separate chaining with other structures Open addressing Coalesced hashing Cuckoo hashing Hopscotch hashing Robin Hood hashing choice hashing Dynamic resizing Resizing by copying all entries Alternatives all at once rehashing Incremental resizing Monotonic keys Linear hashing Hashing distributed hash tables Performance analysis Features Advantages Drawbacks Uses Associative arrays Database indexing Caches Sets Object representation Unique data representation Transposition table Implementations In programming languages History See also Related data structures References Further reading External links Hashing edit Main article Hash function idea hashing distribute entries key value pairs across an array buckets Given key algorithm computes an index that suggests entry can be found index f key array size Often this done in two steps hash hashfunc key index hash array size In this method hash independent array size it then reduced an index number between array size using modulo operator In case that array size power two remainder operation reduced masking which improves speed but can increase problems with poor hash function Choosing hash function edit basic requirement that function should provide uniform distribution hash values non uniform distribution increases number collisions cost resolving them Uniformity sometimes difficult ensure by design but may be evaluated empirically using statistical tests e g Pearson s chi squared test discrete uniform distributions distribution needs be uniform only table sizes that occur in application In particular if one uses dynamic resizing with exact doubling halving table size then hash function needs be uniform only size power two Here index can be computed as some range bits hash function On other hand some hashing algorithms prefer have size be prime number modulus operation may provide some additional mixing this especially useful with poor hash function open addressing schemes hash function should also avoid clustering mapping two more keys consecutive slots Such clustering may cause lookup cost skyrocket even if load factor low collisions are infrequent popular multiplicative hash claimed have particularly poor clustering behavior Cryptographic hash functions are believed provide good hash functions any table size either by modulo reduction by bit masking citation needed They may also be appropriate if risk malicious users trying sabotage network service by submitting requests designed generate large number collisions in server s hash tables However risk sabotage can also be avoided by cheaper methods such as applying secret salt data using universal hash function drawback cryptographic hashing functions that they are often slower compute which means that in cases uniformity any size not necessary non cryptographic hashing function might be preferable citation needed Perfect hash function edit If all keys are known ahead time perfect hash function can be used create perfect hash table that has no collisions If minimal perfect hashing used every location in hash table can be used as well Perfect hashing allows constant time lookups in all cases This in contrast most chaining open addressing methods time lookup low on average but may be very large O n instance all keys hash few values Key statistics edit critical statistic hash table load factor defined as load factor n k displaystyle text load factor frac n k n number entries occupied in hash table k number buckets As load factor grows larger hash table becomes slower it may even fail work depending on method used expected constant time property hash table assumes that load factor be kept below some bound fixed number buckets time lookup grows with number entries therefore desired constant time not achieved In some implementations solution automatically grow usually double size table load factor bound reached thus forcing re hash all entries As real world example default load factor HashMap in Java which offers good trade off between time space costs Second load factor one can examine variance number entries per bucket example two tables both have entries buckets one has exactly one entry in each bucket other has all entries in same bucket Clearly hashing not working in second one low load factor not especially beneficial As load factor approaches proportion unused areas in hash table increases but not necessarily any reduction in search cost This results in wasted memory Collision resolution edit Hash collisions are practically unavoidable hashing random subset large set possible keys example if keys are hashed into million buckets even with perfectly uniform random distribution according birthday problem approximately chance at least two keys being hashed same slot Therefore almost all hash table implementations have some collision resolution strategy handle such events Some common strategies are described below All these methods require that keys pointers them be stored in table together with associated values Separate chaining edit Hash collision resolved by separate chaining In method known as separate chaining each bucket independent has some sort list entries with same index time hash table operations time find bucket which constant plus time list operation In good hash table each bucket has zero one entries sometimes two three but rarely more than that Therefore structures that are efficient in time space these cases are preferred Structures that are efficient fairly large number entries per bucket are not needed desirable If these cases happen often hashing function needs be fixed citation needed Separate chaining with linked lists edit Chained hash tables with linked lists are popular they require only basic data structures with simple algorithms can use simple hash functions that are unsuitable other methods citation needed cost table operation that scanning entries selected bucket desired key If distribution keys sufficiently uniform average cost lookup depends only on average number keys per bucket that it roughly proportional load factor this reason chained hash tables remain effective even number table entries n much higher than number slots example chained hash table with slots stored keys load factor five ten times slower than slot table load factor but still times faster than plain sequential list separate chaining worst case scenario all entries are inserted into same bucket in which case hash table ineffective cost that searching bucket data structure If latter linear list lookup procedure may have scan all its entries so worst case cost proportional number n entries in table bucket chains are often searched sequentially using order entries were added bucket If load factor large some keys are more likely come up than others then rearranging chain with move front heuristic may be effective More sophisticated data structures such as balanced search trees are worth considering only if load factor large about more if hash distribution likely be very non uniform if one must guarantee good performance even in worst case scenario However using larger table better hash function may be even more effective in those cases citation needed Chained hash tables also inherit disadvantages linked lists storing small keys values space overhead next pointer in each entry record can be significant An additional disadvantage that traversing linked list has poor cache performance making processor cache ineffective Separate chaining with list head cells edit Hash collision by separate chaining with head records in bucket array Some chaining implementations store first record each chain in slot array itself number pointer traversals decreased by one most cases purpose increase cache efficiency hash table access disadvantage that an empty bucket takes same space as bucket with one entry save space such hash tables often have about as many slots as stored entries meaning that many slots have two more entries citation needed Separate chaining with other structures edit Instead list one can use any other data structure that supports required operations example by using self balancing binary search tree theoretical worst case time common hash table operations insertion deletion lookup can be brought down O log n rather than O n However this introduces extra complexity into implementation may cause even worse performance smaller hash tables time spent inserting into balancing tree greater than time needed perform linear search on all elements list real world example hash table that uses self balancing binary search tree buckets HashMap class in Java version variant called array hash table uses dynamic array store all entries that hash same slot Each newly inserted entry gets appended end dynamic array that assigned slot dynamic array resized in an exact fit manner meaning it grown only by as many bytes as needed Alternative techniques such as growing array by block sizes pages were found improve insertion performance but at cost in space This variation makes more efficient use CPU caching translation lookaside buffer TLB slot entries are stored in sequential memory positions It also dispenses with next pointers that are required by linked lists which saves space Despite frequent array resizing space overheads incurred by operating system such as memory fragmentation were found be small citation needed An elaboration on this approach so called dynamic perfect hashing bucket that contains k entries organized as perfect hash table with k slots While it uses more memory n slots n entries in worst case n k slots in average case this variant has guaranteed constant worst case lookup time low amortized time insertion It also possible use fusion tree each bucket achieving constant time all operations with high probability Open addressing edit Main article Open addressing Hash collision resolved by open addressing with linear probing interval Note that Ted Baker has unique hash but nevertheless collided with Sandra Dee that had previously collided with John Smith In another strategy called open addressing all entry records are stored in bucket array itself new entry has be inserted buckets are examined starting with hashed slot proceeding in some probe sequence until an unoccupied slot found searching an entry buckets are scanned in same sequence until either target record found an unused array slot found which indicates that no such key in table name open addressing refers fact that location address item not determined by its hash value This method also called closed hashing it should not be confused with open hashing closed addressing that usually mean separate chaining Well known probe sequences include Linear probing in which interval between probes fixed usually Quadratic probing in which interval between probes increased by adding successive outputs quadratic polynomial starting value given by original hash computation Double hashing in which interval between probes computed by second hash function drawback all these open addressing schemes that number stored entries cannot exceed number slots in bucket array In fact even with good hash functions performance dramatically degrades load factor grows beyond so many applications these restrictions mandate use dynamic resizing with its attendant costs citation needed Open addressing schemes also put more stringent requirements on hash function besides distributing keys more uniformly over buckets function must also minimize clustering hash values that are consecutive in probe order Using separate chaining only concern that many objects map same hash value whether they are adjacent nearby completely irrelevant citation needed Open addressing only saves memory if entries are small less than four times size pointer load factor not small If load factor close zero that are far more buckets than stored entries open addressing wasteful even if each entry just two words This graph compares average number cache misses required look up elements in tables with chaining linear probing As table passes full mark linear probing s performance drastically degrades Open addressing avoids time overhead allocating each new entry record can be implemented even in absence memory allocator It also avoids extra indirection required access first entry each bucket that usually only one It also has better locality reference particularly with linear probing With small record sizes these factors can yield better performance than chaining particularly lookups Hash tables with open addressing are also easier serialize they do not use pointers citation needed On other hand normal open addressing poor choice large elements these elements fill entire CPU cache lines negating cache advantage large amount space wasted on large empty table slots If open addressing table only stores references elements external storage it uses space comparable chaining even large records but loses its speed advantage citation needed Generally speaking open addressing better used hash tables with small records that can be stored within table internal storage fit in cache line They are particularly suitable elements one word less If table expected have high load factor records are large data variable sized chained hash tables often perform as well better citation needed Coalesced hashing edit hybrid chaining open addressing coalesced hashing links together chains nodes within table itself Like open addressing it achieves space usage somewhat diminished cache advantages over chaining Like chaining it does not exhibit clustering effects in fact table can be efficiently filled high density Unlike chaining it cannot have more elements than table slots Cuckoo hashing edit Another alternative open addressing solution cuckoo hashing which ensures constant lookup deletion time in worst case constant amortized time insertions with low probability that worst case will be encountered It uses two more hash functions which means any key value pair could be in two more locations lookup first hash function used if key value not found then second hash function used so on If collision happens during insertion then key re hashed with second hash function map it another bucket If all hash functions are used still collision then key it collided with removed make space new key old key re hashed with one other hash functions which maps it another bucket If that location also results in collision then process repeats until no collision process traverses all buckets at which point table resized By combining multiple hash functions with multiple cells per bucket very high space utilization can be achieved citation needed Hopscotch hashing edit Another alternative open addressing solution hopscotch hashing which combines approaches cuckoo hashing linear probing yet seems in general avoid limitations In particular it works well even load factor grows beyond algorithm well suited implementing resizable concurrent hash table hopscotch hashing algorithm works by defining neighborhood buckets near original hashed bucket given entry always found Thus search limited number entries in this neighborhood which logarithmic in worst case constant on average with proper alignment neighborhood typically requires one cache miss inserting an entry one first attempts add it bucket in neighborhood However if all buckets in this neighborhood are occupied algorithm traverses buckets in sequence until an open slot an unoccupied bucket found as in linear probing At that point since empty bucket outside neighborhood items are repeatedly displaced in sequence hops This similar cuckoo hashing but with difference that in this case empty slot being moved into neighborhood instead items being moved out with hope eventually finding an empty slot Each hop brings open slot closer original neighborhood without invalidating neighborhood property any buckets along way In end open slot has been moved into neighborhood entry being inserted can be added it citation needed Robin Hood hashing edit One interesting variation on double hashing collision resolution Robin Hood hashing idea that new key may displace key already inserted if its probe count larger than that key at current position net effect this that it reduces worst case search times in table This similar ordered hash tables except that criterion bumping key does not depend on direct relationship between keys Since both worst case variation in number probes reduced dramatically an interesting variation probe table starting at expected successful probe value then expand from that position in both directions External Robin Hood hashing an extension this algorithm table stored in an external file each table position corresponds fixed sized page bucket with B records choice hashing edit choice hashing employs two different hash functions h x h x hash table Both hash functions are used compute two table locations an object inserted in table it placed in table location that contains fewer objects with default being h x table location if equality in bucket size choice hashing employs principle power two choices Dynamic resizing edit an insert made such that number entries in hash table exceeds product load factor current capacity then hash table will need be rehashed Rehashing includes increasing size underlying data structure mapping existing items new bucket locations In some implementations if initial capacity greater than maximum number entries divided by load factor no rehash operations will ever occur limit proportion memory wasted due empty buckets some implementations also shrink size table followed by rehash items are deleted From point space time tradeoffs this operation similar deallocation in dynamic arrays Resizing by copying all entries edit common approach automatically trigger complete resizing load factor exceeds some threshold rmax Then new larger table allocated each entry removed from old table inserted into new table all entries have been removed from old table then old table returned free storage pool Likewise load factor falls below second threshold rmin all entries are moved new smaller table hash tables that shrink grow frequently resizing downward can be skipped entirely In this case table size proportional maximum number entries that ever were in hash table at one time rather than current number disadvantage that memory usage will be higher thus cache behavior may be worse best control shrink fit operation can be provided that does this only on request If table size increases decreases by fixed percentage at each expansion total cost these resizings amortized over all insert delete operations still constant independent number entries n number m operations performed example consider table that was created with minimum possible size doubled each time load ratio exceeds some threshold If m elements are inserted into that table total number extra re insertions that occur in all dynamic resizings table at most m In other words dynamic resizing roughly doubles cost each insert delete operation Alternatives all at once rehashing edit Some hash table implementations notably in real time systems cannot pay price enlarging hash table all at once it may interrupt time critical operations If one cannot avoid dynamic resizing solution perform resizing gradually Disk based hash tables almost always use some alternative all at once rehashing since cost rebuilding entire table on disk would be high Incremental resizing edit One alternative enlarging table all at once perform rehashing gradually During resize allocate new hash table but keep old table unchanged In each lookup delete operation check both tables Perform insertion operations only in new table At each insertion also move r elements from old table new table all elements are removed from old table deallocate it ensure that old table completely copied over before new table itself needs be enlarged it necessary increase size table by factor at least r r during resizing Monotonic keys edit If it known that key values will always increase decrease monotonically then variation consistent hashing can be achieved by keeping list single most recent key value at each hash table resize operation Upon lookup keys that fall in ranges defined by these list entries are directed appropriate hash function indeed hash table both which can be different each range Since it common grow overall number entries by doubling will only be O log N ranges check binary search time redirection would be O log log N As with consistent hashing this approach guarantees that any key s hash once issued will never change even hash table later grown Linear hashing edit Linear hashing hash table algorithm that permits incremental hash table expansion It implemented using single hash table but with two possible lookup functions Hashing distributed hash tables edit Another way decrease cost table resizing choose hash function in such way that hashes most values do not change table resized Such hash functions are prevalent in disk based distributed hash tables rehashing prohibitively costly problem designing hash such that most values do not change table resized known as distributed hash table problem four most popular approaches are rendezvous hashing consistent hashing content addressable network algorithm Kademlia distance Performance analysis edit In simplest model hash function completely unspecified table does not resize With an ideal hash function table size k displaystyle k with open addressing has no collisions holds up k displaystyle k elements with single comparison successful lookup while table size k displaystyle k with chaining n displaystyle n keys has minimum m x n k displaystyle max n k collisions n k displaystyle Theta frac n k comparisons lookup With worst possible hash function every insertion causes collision hash tables degenerate linear search with n displaystyle Theta n amortized comparisons per insertion up n displaystyle n comparisons successful lookup Adding rehashing this model straightforward As in dynamic array geometric resizing by factor b displaystyle b implies that only n b i displaystyle frac n b i keys are inserted i displaystyle i more times so that total number insertions bounded above by b n b displaystyle frac bn b which n displaystyle Theta n By using rehashing maintain n k displaystyle n k tables using both chaining open addressing can have unlimited elements perform successful lookup in single comparison best choice hash function In more realistic models hash function random variable over probability distribution hash functions performance computed on average over choice hash function this distribution uniform assumption called simple uniform hashing it can be shown that hashing with chaining requires n k displaystyle Theta frac n k comparisons on average an unsuccessful lookup hashing with open addressing requires n k displaystyle Theta left frac n k right Both these bounds are constant if we maintain n k c displaystyle frac n k c using table resizing c displaystyle c fixed constant less than Features edit Advantages edit main advantage hash tables over other table data structures speed This advantage more apparent number entries large Hash tables are particularly efficient maximum number entries can be predicted in advance so that bucket array can be allocated once with optimum size never resized If set key value pairs fixed known ahead time so insertions deletions are not allowed one may reduce average lookup cost by careful choice hash function bucket table size internal data structures In particular one may be able devise hash function that collision free even perfect In this case keys need not be stored in table Drawbacks edit Although operations on hash table take constant time on average cost good hash function can be significantly higher than inner loop lookup algorithm sequential list search tree Thus hash tables are not effective number entries very small However in some cases high cost computing hash function can be mitigated by saving hash value together with key certain string processing applications such as spell checking hash tables may be less efficient than tries finite automata Judy arrays Also if are not many possible keys store that if each key can be represented by small enough number bits then instead hash table one may use key directly as index into an array values Note that are no collisions in this case entries stored in hash table can be enumerated efficiently at constant cost per entry but only in some pseudo random order Therefore no efficient way locate an entry whose key nearest given key Listing all n entries in some specific order generally requires separate sorting step whose cost proportional log n per entry In comparison ordered search trees have lookup insertion cost proportional log n but allow finding nearest key at about same cost ordered enumeration all entries at constant cost per entry If keys are not stored hash function collision free may be no easy way enumerate keys that are present in table at any given moment Although average cost per operation constant fairly small cost single operation may be quite high In particular if hash table uses dynamic resizing an insertion deletion operation may occasionally take time proportional number entries This may be serious drawback in real time interactive applications Hash tables in general exhibit poor locality reference that data be accessed distributed seemingly at random in memory hash tables cause access patterns that jump around this can trigger microprocessor cache misses that cause long delays Compact data structures such as arrays searched with linear search may be faster if table relatively small keys are compact optimal performance point varies from system system Hash tables become quite inefficient are many collisions While extremely uneven hash distributions are extremely unlikely arise by chance malicious adversary with knowledge hash function may be able supply information hash that creates worst case behavior by causing excessive collisions resulting in very poor performance e g denial service attack In critical applications data structure with better worst case guarantees can be used however universal hashing randomized algorithm that prevents attacker from predicting which inputs cause worst case behavior may be preferable hash function used by hash table in Linux routing table cache was changed with Linux version as countermeasure against such attacks Uses edit This section does not cite any sources Please help improve this section by adding citations reliable sources Unsourced material may be challenged removed Find sources Hash table news newspapers books scholar JSTOR July Learn remove this template message Associative arrays edit Main article Associative array Hash tables are commonly used implement many types in memory tables They are used implement associative arrays arrays whose indices are arbitrary strings other complicated objects especially in interpreted programming languages like Ruby Python PHP storing new item into multimap hash collision occurs multimap unconditionally stores both items storing new item into typical associative array hash collision occurs but actual keys themselves are different associative array likewise stores both items However if key new item exactly matches key an old item associative array typically erases old item overwrites it with new item so every item in table has unique key Database indexing edit Hash tables may also be used as disk based data structures database indices such as in dbm although B trees are more popular in these applications In multi node database systems hash tables are commonly used distribute rows amongst nodes reducing network traffic hash joins Caches edit Main article Cache computing Hash tables can be used implement caches auxiliary data tables that are used speed up access data that primarily stored in slower media In this application hash collisions can be handled by discarding one two colliding entries usually erasing old item that currently stored in table overwriting it with new item so every item in table has unique hash value Sets edit Besides recovering entry that has given key many hash table implementations can also tell whether such an entry exists not Those structures can therefore be used implement set data structure which merely records whether given key belongs specified set keys In this case structure can be simplified by eliminating all parts that have do with entry values Hashing can be used implement both static dynamic sets Object representation edit Several dynamic languages such as Perl Python JavaScript Lua Ruby use hash tables implement objects In this representation keys are names members methods object values are pointers corresponding member method Unique data representation edit Main article String interning Hash tables can be used by some programs avoid creating multiple character strings with same contents that purpose all strings in use by program are stored in single string pool implemented as hash table which checked whenever new string has be created This technique was introduced in Lisp interpreters under name hash consing can be used with many other kinds data expression trees in symbolic algebra system records in database files in file system binary decision diagrams etc Transposition table edit Main article Transposition table Implementations edit In programming languages edit Many programming languages provide hash table functionality either as built in associative arrays as standard library modules In C example unordered map class provides hash tables keys values arbitrary type Java programming language including variant which used on Android includes HashSet HashMap LinkedHashSet LinkedHashMap generic collections In PHP Zend engine Zend engine respectively use one hash functions from Daniel J Bernstein generate hash values used in managing mappings data pointers stored in hash table In PHP source code it labelled as DJBX Daniel J Bernstein Times with Addition Python s built in hash table implementation in form dict type as well as Perl s hash type are used internally implement namespaces therefore need pay more attention security i e collision attacks Python sets also use hashes internally fast lookup though they store only keys not values In NET Framework support hash tables provided via non generic Hashtable generic Dictionary classes which store key value pairs generic HashSet class which stores only values In Ruby hash table uses open addressing model from Ruby onwards In Rust s standard library generic HashMap HashSet structs use linear probing with Robin Hood bucket stealing ANSI Smalltalk defines classes Set IdentitySet Dictionary IdentityDictionary All Smalltalk implementations provide additional not yet standardized versions WeakSet WeakKeyDictionary WeakValueDictionary Tcl array variables are hash tables Tcl dictionaries are immutable values based on hashes functionality also available as C library functions Tcl InitHashTable et al generic hash tables Tcl NewDictObj et al dictionary values performance has been independently benchmarked as extremely competitive History edit idea hashing arose independently in different places In January Hans Peter Luhn wrote an internal IBM memorandum that used hashing with chaining Gene Amdahl Elaine M McGraw Nathaniel Rochester Arthur Samuel implemented program using hashing at about same time Open addressing with linear probing relatively prime stepping credited Amdahl but Ershov in Russia had same idea See also edit Rabin Karp string search algorithm Stable hashing Consistent hashing Extendible hashing Lazy deletion Pearson hashing PhotoDNA Search data structure Concurrent hash table Related data structures edit are several data structures that use hash functions but cannot be considered special cases hash tables Bloom filter memory efficient data structure designed constant time approximate lookups uses hash function s can be seen as an approximate hash table Distributed hash table DHT resilient dynamic table spread over several nodes network Hash array mapped trie trie structure similar array mapped trie but each key hashed first References edit Cormen Thomas H Leiserson Charles E Rivest Ronald L Stein Clifford Introduction Algorithms rd ed Massachusetts Institute Technology pp ISBN Charles E Leiserson Amortized Algorithms Table Doubling Potential Method Archived August at Wayback Machine Lecture course MIT J J Introduction Algorithms Fall b c Knuth Donald Art Computer Programming Sorting Searching nd ed Addison Wesley pp ISBN b Cormen Thomas H Leiserson Charles E Rivest Ronald L Stein Clifford Chapter Hash Tables Introduction Algorithms nd ed MIT Press McGraw Hill pp ISBN JDK HashMap Hashcode implementation Archived from original on May Pearson Karl On criterion that given system deviations from probable in case correlated system variables such that it can be reasonably supposed have arisen from random sampling Philosophical Magazine Series pp doi Plackett Robin Karl Pearson Chi Squared Test International Statistical Review International Statistical Institute ISI pp doi b Wang Thomas March Prime Double Hash Table Archived from original on September Retrieved May b c d Javadoc HashMap in Java https docs oracle com javase docs api java util HashMap html Probst Mark April Linear vs Binary Search Archived from original on November Retrieved November does HashMap work in JAVA coding geek com Archived from original on November Askitis Nikolas Zobel Justin October Cache conscious Collision Resolution in String Hash Tables Proceedings th International Conference String Processing Information Retrieval SPIRE pp doi ISBN Askitis Nikolas Sinha Ranjan Engineering scalable cache space efficient tries strings VLDB Journal doi s ISSN Askitis Nikolas Fast Compact Hash Tables Integer Keys PDF Proceedings nd Australasian Computer Science Conference ACSC pp ISBN Archived PDF from original on February Erik Demaine Jeff Lind Advanced Data Structures MIT Computer Science Artificial Intelligence Laboratory Spring Archived copy PDF Archived PDF from original on June Retrieved June CS maint archived copy as title link Willard Dan E Examining computational geometry van Emde Boas trees hashing from perspective fusion tree SIAM Journal on Computing doi S MR b Tenenbaum Aaron M Langsam Yedidyah Augenstein Moshe J Data Structures Using C Prentice Hall pp p ISBN Herlihy Maurice Shavit Nir Tzafrir Moran Hopscotch Hashing DISC Proceedings nd international symposium on Distributed Computing Berlin Heidelberg Springer Verlag pp CiteSeerX Celis Pedro Robin Hood hashing PDF Technical report Computer Science Department University Waterloo CS Archived PDF from original on July Goossaert Emmanuel Robin Hood hashing Archived from original on March Amble Ole Knuth Don Ordered hash tables Computer Journal doi comjnl Viola Alfredo October Exact distribution individual displacements in linear probing hashing Transactions on Algorithms TALG doi Celis Pedro March External Robin Hood Hashing Technical report Computer Science Department Indiana University TR Archived copy PDF Archived PDF from original on March Retrieved April CS maint archived copy as title link Litwin Witold Linear hashing new tool file table addressing Proc th Conference on Very Large Databases pp Doug Dunham CS Lecture Notes Archived July at Wayback Machine University Minnesota Duluth Theorems Last modified April Alexander Klink Julian W lde s Efficient Denial Service Attacks on Web Application Platforms Archived September at Wayback Machine December th Chaos Communication Congress Berlin Germany Mike Lennon Hash Table Vulnerability Enables Wide Scale DDoS Attacks Archived September at Wayback Machine Hardening Perl s Hash Function November Archived from original on September Crosby Wallach Denial Service via Algorithmic Complexity Attacks Archived March at Wayback Machine quote modern universal hashing techniques can yield performance comparable commonplace hash functions while being provably secure against these attacks Universal hash functions are solution suitable adversarial environments in production systems Bar Yosef Noa Wool Avishai Remote algorithmic complexity attacks against randomized hash tables Proc International Conference on Security Cryptography SECRYPT PDF p Archived PDF from original on September Lesson Implementations Java Tutorials Collections docs oracle com Archived from original on January Retrieved April Python List vs Dict look up table stackoverflow com Archived from original on December Retrieved April Dmitriy Vasin June Do Know Hash Table Works Ruby Examples anadea info Retrieved July Jonan Scheffler December Ruby Released Faster Hashes Unified Integers Better Rounding heroku com Retrieved July Wing Eric Hash Table Shootout Rise Interpreter Machines LuaHashMap An easy use hash table library C PlayControl Software Archived from original on October Retrieved October Did Tcl win In any case these benchmarks showed that these interpreter implementations have very good hash implementations are competative with our reference benchmark STL unordered map Particularly in case Tcl Lua they were extremely competative often were within unordered map they weren t beating it On original site still has text but figures appear be broken whereas they are intact in archive b Mehta Dinesh P Sahni Sartaj October Handbook Datastructures Applications p ISBN Further reading edit Tamassia Roberto Goodrich Michael T Chapter Nine Maps Dictionaries Data structures algorithms in Java updated Java th ed Hoboken NJ Wiley pp ISBN McKenzie B J Harries R Bell T February Selecting hashing algorithm Software Practice Experience doi spe External links edit Wikimedia Commons has media related Hash tables Wikibooks has book on topic Data Structures Hash Tables Hash Function Hash Table Lookup by Bob Jenkins Hash Tables by SparkNotes explanation using C Hash functions by Paul Hsieh Design Compact Efficient Hash Tables Java NIST entry on hash tables Lecture on Hash Tables from Stanford s CS Open Data Structures Chapter Hash Tables MIT s Introduction Algorithms Hashing MIT OCW lecture Video MIT s Introduction Algorithms Hashing MIT OCW lecture Video v t e Data structures Types Collection Container Abstract Associative array Multimap List Stack Queue Double ended queue Priority queue Double ended priority queue Set Multiset Disjoint set Arrays Bit array Circular buffer Dynamic array Hash table Hashed array tree Sparse matrix Linked Association list Linked list Skip list Unrolled linked list XOR linked list Trees B tree Binary search tree AA tree AVL tree Red black tree Self balancing tree Splay tree Heap Binary heap Binomial heap Fibonacci heap R tree R tree R tree Hilbert R tree Trie Hash tree Graphs Binary decision diagram Directed acyclic graph Directed acyclic word graph List data structures Retrieved from https en wikipedia org w index php title Hash table oldid Categories Hashing Search algorithms Arrays in computer science Hidden categories Webarchive template wayback links CS long volume value CS maint archived copy as title Use mdy dates from January Articles with short description All articles with unsourced statements Articles with unsourced statements from July Articles with unsourced statements from October Articles with unsourced statements from March Articles needing additional references from July All articles needing additional references Commons category link on Wikidata Commons category link on Wikidata using P Articles with example C code Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Featured content Current events Random article Donate Wikipedia Wikipedia store Interaction Help About Wikipedia Community portal Recent changes Contact page Tools links here Related changes Upload file Special pages Permanent link Page information Wikidata item Cite this page In other projects Wikimedia Commons Print export Create book Download as PDF Printable version Languages Bosanski Catal e tina Dansk Deutsch Eesti Espa ol Esperanto Fran ais Hrvatski Italiano Latvie u Lietuvi Magyar Nederlands Norsk Norsk nynorsk Polski Portugu s Simple English Sloven ina srpski Suomi Svenska Tagalog T rk e Ti ng Vi t Edit links This page was last edited on October at UTC Text available under Creative Commons Attribution ShareAlike License additional terms may apply By using this site agree Terms Use Privacy Policy Wikipedia registered trademark Wikimedia Foundation Inc non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Statistics Cookie statement Mobile view