B tree Wikipedia B tree From Wikipedia free encyclopedia Jump navigation Jump search Not be confused with Binary tree This article s use external links may not follow Wikipedia s policies guidelines Please improve this article by removing excessive inappropriate external links converting useful links appropriate into footnote references October Learn remove this template message B tree Type tree Invented Invented by Rudolf Bayer Edward M McCreight Time complexity in big O notation Algorithm Average Worst case Space O n O n Search O log n O log n Insert O log n O log n Delete O log n O log n In computer science B tree self balancing tree data structure that maintains sorted data allows searches sequential access insertions deletions in logarithmic time B tree generalization binary search tree in that node can have more than two children Unlike other self balancing binary search trees B tree well suited storage systems that read write relatively large blocks data such as discs It commonly used in databases file systems if anything B stands has never been established Contents Origin Overview Variants B tree usage in databases Time search sorted file An index speeds search Insertions deletions Advantages B tree usage databases Technical description Terminology Definition Best case worst case heights Algorithms Search Insertion Deletion Deletion from leaf node Deletion from an internal node Rebalancing after deletion Sequential access Initial construction In filesystems Variations Access concurrency Etymology See also Notes References Original papers External links Origin edit B trees were invented by Rudolf Bayer Edward M McCreight in purpose efficiently managing index pages large random access files basic assumption was that indexes would be so voluminous that only small chunks tree could fit in main memory first article on this invention was written in July published in November Overview edit B tree Bayer McCreight order Knuth In B trees internal non leaf nodes can have variable number child nodes within some pre defined range data inserted removed from node its number child nodes changes In order maintain pre defined range internal nodes may be joined split range child nodes permitted B trees do not need re balancing as frequently as other self balancing search trees but may waste some space since nodes are not entirely full lower upper bounds on number child nodes are typically fixed particular implementation example in B tree often simply referred as tree each internal node may have only child nodes Each internal node B tree contains number keys keys act as separation values which divide its subtrees example if an internal node has child nodes subtrees then it must have keys All values in leftmost subtree will be less than all values in middle subtree will be between all values in rightmost subtree will be greater than Usually number keys chosen vary between d displaystyle d d displaystyle d d displaystyle d minimum number keys d displaystyle d minimum degree branching factor tree In practice keys take up most space in node factor will guarantee that nodes can be split combined If an internal node has d displaystyle d keys then adding key that node can be accomplished by splitting hypothetical d displaystyle d key node into two d displaystyle d key nodes moving key that would have been in middle parent node Each split node has required minimum number keys Similarly if an internal node its neighbor each have d displaystyle d keys then key may be deleted from internal node by combining it with its neighbor Deleting key would make internal node have d displaystyle d keys joining neighbor would add d displaystyle d keys plus one more key brought down from neighbor s parent result an entirely full node d displaystyle d keys number branches child nodes from node will be one more than number keys stored in node In B tree internal nodes will store either one key with two child nodes two keys with three child nodes B tree sometimes described with parameters d displaystyle d d displaystyle d simply with highest branching order d displaystyle d B tree kept balanced after insertion by splitting would be overfilled node d displaystyle d keys into two d displaystyle d key siblings inserting mid value key into parent Depth only increases root split maintaining balance Similarly B tree kept balanced after deletion by merging redistributing keys among siblings maintain d displaystyle d key minimum non root nodes merger reduces number keys in parent potentially forcing it merge redistribute keys with its siblings so on only change in depth occurs root has two children d displaystyle d transitionally d displaystyle d keys in which case two siblings parent are merged reducing depth by one This depth will increase slowly as elements are added tree but an increase in overall depth infrequent results in all leaf nodes being one more node farther away from root B trees have substantial advantages over alternative implementations time access data node greatly exceeds time spent processing that data then cost accessing node may be amortized over multiple operations within node This usually occurs node data are in secondary storage such as disk drives By maximizing number keys within each internal node height tree decreases number expensive node accesses reduced In addition rebalancing tree occurs less often maximum number child nodes depends on information that must be stored each child node size full disk block an analogous size in secondary storage While B trees are easier explain practical B trees using secondary storage need large number child nodes improve performance Variants edit term B tree may refer specific design it may refer general class designs In narrow sense B tree stores keys in its internal nodes but need not store those keys in records at leaves general class includes variations such as B tree B tree In B tree copies keys are stored in internal nodes keys records are stored in leaves in addition leaf node may include pointer next leaf node speed sequential access B tree balances more neighboring internal nodes keep internal nodes more densely packed This variant ensures non root nodes are at least full instead Knuth p As most costly part operation inserting node in B tree splitting node B trees are created postpone splitting operation as long as they can maintain this instead immediately splitting up node it gets full its keys are shared with node next it This spill operation less costly do than split it requires only shifting keys between existing nodes not allocating memory new one inserting first it checked whether node has some free space in it if so new key just inserted in node However if node full it has m keys m order tree as maximum number pointers subtrees from one node it needs be checked whether right sibling exists has some free space If right sibling has j m keys then keys are redistributed between two sibling nodes as evenly as possible this purpose m keys from current node new key inserted one key from parent node j keys from sibling node are seen as an ordered array m j keys array becomes split by half so that m j lowest keys stay in current node next middle key inserted in parent rest go right sibling newly inserted key might end up in any three places situation right sibling full left isn t analogous both sibling nodes are full then two nodes current node sibling are split into three one more key shifted up tree parent node If parent full then spill split operation propagates towards root node Deleting nodes somewhat more complex than inserting however B trees can be turned into order statistic trees allow rapid searches Nth record in key order counting number records between any two records various other related operations B tree usage in databases edit Time search sorted file edit Usually sorting searching algorithms have been characterized by number comparison operations that must be performed using order notation binary search sorted table with N records example can be done in roughly log N comparisons If table had records then specific record could be located with at most comparisons log Large databases have historically been kept on disk drives time read record on disk drive far exceeds time needed compare keys once record available time read record from disk drive involves seek time rotational delay seek time may be more milliseconds rotational delay averages about half rotation period RPM drive rotation period milliseconds drive such as Seagate ST NS track track seek time milliseconds average reading seek time milliseconds simplicity assume reading from disk takes about milliseconds Naively then time locate one record out million would take disk reads times milliseconds per disk read which seconds time won t be that bad individual records are grouped together in disk block disk block might be kilobytes If each record bytes then records could be stored in each block disk read time above was actually an entire block Once disk head in position one more disk blocks can be read with little delay With records per block last so comparisons don t need do any disk reads comparisons are all within last disk block read speed search further first comparisons which each required disk access must be sped up An index speeds search edit This section needs additional citations verification Please help improve this article by adding citations reliable sources Unsourced material may be challenged removed Find sources B tree news newspapers books scholar JSTOR March Learn remove this template message significant improvement can be made with an index In example above initial disk reads narrowed search range by factor two That can be improved substantially by creating an auxiliary index that contains first record in each disk block sometimes called sparse index This auxiliary index would be size original database but it can be searched more quickly Finding an entry in auxiliary index would tell us which block search in main database after searching auxiliary index we would have search only that one block main database at cost one more disk read index would hold entries so it would take at most comparisons Like main database last six so comparisons in auxiliary index would be on same disk block index could be searched in about eight disk reads desired record could be accessed in disk reads trick creating an auxiliary index can be repeated make an auxiliary index auxiliary index That would make an aux aux index that would need only entries would fit in one disk block Instead reading disk blocks find desired record we only need read blocks This blocking core idea behind creation B tree disk blocks fill out hierarchy levels make up index Reading searching first only block aux aux index which root tree identifies relevant block in aux index in level below Reading searching that aux index block identifies relevant block read until final level known as leaf level identifies record in main database Instead milliseconds we need only milliseconds get record auxiliary indices have turned search problem from binary search requiring roughly log N disk reads one requiring only logb N disk reads b blocking factor number entries per block b entries per block in our example log reads In practice if main database being frequently searched aux aux index much aux index may reside in disk cache so they would not incur disk read Insertions deletions edit This section needs additional citations verification Please help improve this article by adding citations reliable sources Unsourced material may be challenged removed Find sources B tree news newspapers books scholar JSTOR March Learn remove this template message If database does not change then compiling index simple do index need never be changed If are changes then managing database its index becomes more complicated Deleting records from database relatively easy index can stay same record can just be marked as deleted database remains in sorted order If are large number deletions then searching storage become less efficient Insertions can be very slow in sorted sequential file room inserted record must be made Inserting record before first record requires shifting all records down one Such an operation just expensive be practical One solution leave some spaces Instead densely packing all records in block block can have some free space allow subsequent insertions Those spaces would be marked as if they were deleted records Both insertions deletions are fast as long as space available on block If an insertion won t fit on block then some free space on some nearby block must be found auxiliary indices adjusted hope that enough space available nearby such that lot blocks do not need be reorganized Alternatively some out sequence disk blocks may be used Advantages B tree usage databases edit B tree uses all ideas described above In particular B tree keeps keys in sorted order sequential traversing uses hierarchical index minimize number disk reads uses partially full blocks speed insertions deletions keeps index balanced with recursive algorithm In addition B tree minimizes waste by making sure interior nodes are at least half full B tree can handle an arbitrary number insertions deletions Technical description edit Terminology edit literature on B trees not uniform in its terminology Folk Zoellick p Bayer McCreight Comer others define order B tree as minimum number keys in non root node Folk Zoellick points out that terminology ambiguous maximum number keys not clear An order B tree might hold maximum keys maximum keys Knuth p avoids problem by defining order be maximum number children which one more than maximum number keys term leaf also inconsistent Bayer McCreight considered leaf level be lowest level keys but Knuth considered leaf level be one level below lowest keys Folk Zoellick p are many possible implementation choices In some designs leaves may hold entire data record in other designs leaves may only hold pointers data record Those choices are not fundamental idea B tree simplicity most authors assume are fixed number keys that fit in node basic assumption key size fixed node size fixed In practice variable length keys may be employed Folk Zoellick p Definition edit According Knuth s definition B tree order m tree which satisfies following properties Every node has at most m children Every non leaf node except root has at least m child nodes root has at least two children if it not leaf node non leaf node with k children contains k keys All leaves appear in same level carry no information Each internal node s keys act as separation values which divide its subtrees example if an internal node has child nodes subtrees then it must have keys All values in leftmost subtree will be less than all values in middle subtree will be between all values in rightmost subtree will be greater than Internal nodes Internal nodes are all nodes except leaf nodes root node They are usually represented as an ordered set elements child pointers Every internal node contains maximum U children minimum L children Thus number elements always less than number child pointers number elements between L U U must be either L L therefore each internal node at least half full relationship between U L implies that two half full nodes can be joined make legal node one full node can be split into two legal nodes if s room push one element up into parent These properties make it possible delete insert new values into B tree adjust tree preserve B tree properties root node root node s number children has same upper limit as internal nodes but has no lower limit example are fewer than L elements in entire tree root will be only node in tree with no children at all Leaf nodes In Knuth s terminology leaf nodes do not carry any information internal nodes that are one level above leaves are would be called leaves by other authors these nodes only store keys at most m at least m if they are not root pointers nodes carrying no information B tree depth n can hold about U times as many items as B tree depth n but cost search insert delete operations grows with depth tree As with any balanced tree cost grows much more slowly than number elements Some balanced trees store values only at leaf nodes use different kinds nodes leaf nodes internal nodes B trees keep values in every node in tree except leaf nodes Best case worst case heights edit Let h be height classic B tree see Tree data structure Terminology tree height definition Let n be number entries in tree Let m be maximum number children node can have Each node can have at most m keys It can be shown by induction example that B tree height h with all its nodes completely filled has n mh entries Hence best case height i e minimum height B tree h m i n log m n displaystyle h mathrm min lceil log m n rceil Let d displaystyle d be minimum number children an internal non root node can have an ordinary B tree d m displaystyle d left lceil m right rceil Comer p Cormen et al pp give worst case height maximum height B tree as h m x log d n displaystyle h mathrm max left lfloor log d frac n right rfloor Algorithms edit This article may be confusing unclear readers In particular discussion below uses element value key separator separation value mean essentially same thing terms are not clearly defined are some subtle issues at root leaves Please help us clarify article might be discussion about this on talk page February Learn remove this template message Search edit Searching similar searching binary search tree Starting at root tree recursively traversed from top bottom At each level search reduces its field view child pointer subtree whose range includes search value subtree s range defined by values keys contained in its parent node These limiting values are also known as separation values Binary search typically but not necessarily used within nodes find separation values child tree interest Insertion edit B Tree insertion example with each iteration nodes this B tree have at most children Knuth order All insertions start at leaf node insert new element search tree find leaf node new element should be added Insert new element into that node with following steps If node contains fewer than maximum allowed number elements then room new element Insert new element in node keeping node s elements ordered Otherwise node full evenly split it into two nodes so single median chosen from among leaf s elements new element Values less than median are put in new left node values greater than median are put in new right node with median acting as separation value separation value inserted in node s parent which may cause it be split so on If node has no parent i e node was root create new root above this node increasing height tree If splitting goes all way up root it creates new root with single separator value two children which lower bound on size internal nodes does not apply root maximum number elements per node U node split one element moves parent but one element added So it must be possible divide maximum number U elements into two legal nodes If this number odd then U L one new nodes contains U L elements hence legal node other contains one more element hence it legal If U even then U L so are L elements in node Half this number L which minimum number elements allowed per node An alternative algorithm supports single pass down tree from root node insertion will take place splitting any full nodes encountered on way preemptively This prevents need recall parent nodes into memory which may be expensive if nodes are on secondary storage However use this algorithm we must be able send one element parent split remaining U elements into two legal nodes without adding new element This requires U L rather than U L which accounts some which textbooks impose this requirement in defining B trees Deletion edit are two popular strategies deletion from B tree Locate delete item then restructure tree retain its invariants OR Do single pass down tree but before entering visiting node restructure tree so that once key be deleted encountered it can be deleted without triggering need any further restructuring algorithm below uses former strategy are two special cases consider deleting an element element in an internal node separator its child nodes Deleting an element may put its node under minimum number elements children procedures these cases are in order below Deletion from leaf node edit Search value delete If value in leaf node simply delete it from node If underflow happens rebalance tree as described in section Rebalancing after deletion below Deletion from an internal node edit Each element in an internal node acts as separation value two subtrees therefore we need find replacement separation Note that largest element in left subtree still less than separator Likewise smallest element in right subtree still greater than separator Both those elements are in leaf nodes either one can be new separator two subtrees Algorithmically described below Choose new separator either largest element in left subtree smallest element in right subtree remove it from leaf node it in replace element be deleted with new separator previous step deleted an element new separator from leaf node If that leaf node now deficient has fewer than required number nodes then rebalance tree starting from leaf node Rebalancing after deletion edit Rebalancing starts from leaf proceeds toward root until tree balanced If deleting an element from node has brought it under minimum size then some elements must be redistributed bring all nodes up minimum Usually redistribution involves moving an element from sibling node that has more than minimum number nodes That redistribution operation called rotation If no sibling can spare an element then deficient node must be merged with sibling merge causes parent lose separator element so parent may become deficient need rebalancing merging rebalancing may continue all way root Since minimum element count doesn t apply root making root be only deficient node not problem algorithm rebalance tree as follows citation needed If deficient node s right sibling exists has more than minimum number elements then rotate left Copy separator from parent end deficient node separator moves down deficient node now has minimum number elements Replace separator in parent with first element right sibling right sibling loses one node but still has at least minimum number elements tree now balanced Otherwise if deficient node s left sibling exists has more than minimum number elements then rotate right Copy separator from parent start deficient node separator moves down deficient node now has minimum number elements Replace separator in parent with last element left sibling left sibling loses one node but still has at least minimum number elements tree now balanced Otherwise if both immediate siblings have only minimum number elements then merge with sibling sandwiching separator taken off from parent Copy separator end left node left node may be deficient node it may be sibling with minimum number elements Move all elements from right node left node left node now has maximum number elements right node empty Remove separator from parent along with its empty right child parent loses an element If parent root now has no elements then free it make merged node new root tree becomes shallower Otherwise if parent has fewer than required number elements then rebalance parent Note rebalancing operations are different B trees e g rotation different parent has copy key B tree e g three siblings are merged into two siblings Sequential access edit While freshly loaded databases tend have good sequential behavior this behavior becomes increasingly difficult maintain as database grows resulting in more random O performance challenges Initial construction edit This section does not cite any sources Please help improve this section by adding citations reliable sources Unsourced material may be challenged removed Find sources B tree news newspapers books scholar JSTOR April Learn remove this template message common special case adding large amount pre sorted data into an initially empty B tree While it quite possible simply perform series successive inserts inserting sorted data results in tree composed almost entirely half full nodes Instead special bulk loading algorithm can be used produce more efficient tree with higher branching factor input sorted all insertions are at rightmost edge tree in particular any time node split we are guaranteed that no more insertions will take place in left half bulk loading we take advantage this instead splitting overfull nodes evenly split them as unevenly as possible leave left node completely full create right node with zero keys one child in violation usual B tree rules At end bulk loading tree composed almost entirely completely full nodes only rightmost node on each level may be less than full those nodes may also be less than half full re establish normal B tree rules combine such nodes with guaranteed full left siblings divide keys produce two nodes at least half full only node which lacks full left sibling root which permitted be less than half full In filesystems edit In addition its use in databases B tree Variants also used in filesystems allow quick random access an arbitrary block in particular file basic problem turning file block i displaystyle i address into disk block perhaps cylinder head sector address Some operating systems require user allocate maximum size file file created file can then be allocated as contiguous disk blocks In that case convert file block address i displaystyle i into disk block address operating system simply adds file block address i displaystyle i address first disk block constituting file scheme simple but file cannot exceed its created size Other operating systems allow file grow resulting disk blocks may not be contiguous so mapping logical blocks physical blocks more involved MS DOS example used simple File Allocation Table FAT FAT has an entry each disk block note that entry identifies whether its block used by file if so which block if any next disk block same file So allocation each file represented as linked list in table In order find disk address file block i displaystyle i operating system disk utility must sequentially follow file s linked list in FAT Worse find free disk block it must sequentially scan FAT MS DOS that was not huge penalty disks files were small FAT had few entries relatively short file chains In FAT filesystem used on floppy disks early hard disks were no more than note entries FAT would usually be resident in memory As disks got bigger FAT architecture began confront penalties On large disk using FAT it may be necessary perform disk reads learn disk location file block be read written TOPS possibly TENEX used level tree that has similarities B tree citation needed disk block was bit words If file fit in word block then file directory would point that physical disk block If file fit in words then directory would point an aux index words that index would either be NULL block isn t allocated point physical address block If file fit in words then directory would point block holding an aux aux index each entry would either be NULL point an aux index Consequently physical disk block word file could be located in two disk reads read on third Apple s filesystem HFS Microsoft s NTFS AIX jfs some Linux filesystems such as btrfs Ext use B trees B trees are used in HFS Reiser file systems DragonFly BSD s HAMMER file system uses modified B tree Variations edit Access concurrency edit Lehman Yao showed that all read locks could be avoided thus concurrent access greatly improved by linking tree blocks at each level together with next pointer This results in tree structure both insertion search operations descend from root leaf Write locks are only required as tree block modified This maximizes access concurrency by multiple users an important consideration databases other B tree based ISAM storage methods cost associated with this improvement that empty pages cannot be removed from btree during normal operations However see various strategies implement node merging source code at United States Patent granted in appears show way use Meta Access Method allow concurrent B tree access modification without locks technique accesses tree upwards both searches updates by means additional in memory indexes that point at blocks in each level in block cache No reorganization deletes needed are no next pointers in each block as in Lehman Yao Etymology edit Rudolf Bayer Ed McCreight invented B tree while working at Boeing Research Labs in Bayer McCreight but did not explain if anything B stands Boeing balanced broad bushy Bayer have been suggested Comer p footnote McCreight has said that more think about B in B trees means better understand B trees See also edit B tree R tree Red black tree tree tree Notes edit FAT called disk block here FAT documentation calls cluster which fixed size group one more contiguous whole physical disk sectors purposes this discussion cluster has no significant difference from physical sector Two these were reserved special purposes so only could actually represent disk blocks clusters References edit b c Comer Douglas June Ubiquitous B Tree Computing Surveys doi Bayer R McCreight E Organization maintenance large ordered indices Proceedings ACM SIGFIDET now SIGMOD Workshop on Data Description Access Control SIGFIDET Houston Texas ACM Press doi b c d e f Toma evi Milo Algorithms Data Structures Belgrade Serbia Akademska misao pp ISBN Counted B Trees retrieved Seagate Technology LLC Product Manual Barracuda ES Serial ATA Rev F publication page Bayer McCreight avoided issue by saying an index element physically adjacent pair x x key some associated information associated information might be pointer record records in random access but it was didn t really matter Bayer McCreight states this paper associated information no further interest Cache Oblivious B trees State University New York SUNY at Stony Brook Retrieved Mark Russinovich Inside Win K NTFS Part Microsoft Developer Network Archived from original on April Retrieved Matthew Dillon HAMMER Filesystem PDF Efficient locking concurrent operations on B trees Portal acm org doi Retrieved http www dtic mil cgi bin GetTRDoc AD ADA Location U doc GetTRDoc pdf Downloads high concurrency btree High Concurrency B Tree code in C GitHub Project Hosting Retrieved Lockless concurrent B tree index meta access method cached nodes b Weiner Peter G August Edward M McCreight via Vimeo Stanford Center Professional Development scpd stanford edu General Bayer R McCreight E Organization Maintenance Large Ordered Indexes PDF Acta Informatica doi bf Comer Douglas June Ubiquitous B Tree Computing Surveys doi ISSN Cormen Thomas Leiserson Charles Rivest Ronald Stein Clifford Introduction Algorithms Second ed MIT Press McGraw Hill pp ISBN Chapter B Trees Folk Michael J Zoellick Bill File Structures nd ed Addison Wesley ISBN Knuth Donald Sorting Searching Art Computer Programming Volume Second ed Addison Wesley ISBN Section Multiway Trees pp Also pp section Balanced Trees discusses trees Original papers edit Bayer Rudolf McCreight E July Organization Maintenance Large Ordered Indices Mathematical Information Sciences Report No Boeing Scientific Research Laboratories Bayer Rudolf Binary B Trees Virtual Memory Proceedings ACM SIGFIDET Workshop on Data Description Access Control San Diego California External links edit Wikimedia Commons has media related B Trees B tree lecture by David Scot Taylor SJSU B Tree visualisation click init B tree UB tree on Scholarpedia Curator Dr Rudolf Bayer B Trees Balanced Tree Data Structures NIST s Dictionary Algorithms Data Structures B tree B Tree Tutorial InfinityDB BTree implementation Cache Oblivious B trees Dictionary Algorithms Data Structures entry B tree Open Data Structures Section B Trees Counted B Trees B Tree Net modern virtualized RAM Disk implementation Bulk loading Shetty Soumya B user configurable implementation B trees Thesis Iowa State University Kald r m Semih April File Organization ISAM B Tree Bulk Loading PDF Ankara Turkey Bilkent University pp ECS B Database System Implementation Lecture PDF University California Davis April p BULK INSERT Transact SQL in SQL Server Microsoft Docs September v t e Tree data structures Search trees dynamic sets associative arrays AA b AVL B B B Bx Optimal Binary search Dancing HTree Interval Order statistic Left leaning Red black Scapegoat Splay T Treap UB Weight balanced Heaps Binary Binomial Brodal Fibonacci Leftist Pairing Skew van Emde Boas Weak Tries Ctrie C trie compressed ADT Hash Radix Suffix Ternary search X fast Y fast Spatial data partitioning trees Ball BK BSP Cartesian Hilbert R k d implicit k d M Metric MVP Octree Priority R Quad R R R Segment VP X Other trees Cover Exponential Fenwick Finger Fractal tree index Fusion Hash calendar iDistance K ary Left child right sibling Link cut Log structured merge Merkle PQ Range SPQR Top v t e Data structures Types Collection Container Abstract Associative array Multimap List Stack Queue Double ended queue Priority queue Double ended priority queue Set Multiset Disjoint set Arrays Bit array Circular buffer Dynamic array Hash table Hashed array tree Sparse matrix Linked Association list Linked list Skip list Unrolled linked list XOR linked list Trees B tree Binary search tree AA tree AVL tree Red black tree Self balancing tree Splay tree Heap Binary heap Binomial heap Fibonacci heap R tree R tree R tree Hilbert R tree Trie Hash tree Graphs Binary decision diagram Directed acyclic graph Directed acyclic word graph List data structures Retrieved from https en wikipedia org w index php title B tree oldid Categories Computer related introductions in B tree Database index techniques Hidden categories Wikipedia external links cleanup from October Wikipedia spam cleanup from October Articles needing additional references from March All articles needing additional references Wikipedia articles needing clarification from February All Wikipedia articles needing clarification All articles with specifically marked weasel worded phrases Articles with specifically marked weasel worded phrases from September All articles with unsourced statements Articles with unsourced statements from July Articles needing additional references from April Articles with unsourced statements from October CS long volume value Commons category link on Wikidata Navigation menu Personal tools Not logged in Talk Contributions Create account Log in Namespaces Article Talk Variants Views Read Edit View history More Search Navigation Main page Contents Featured content Current events Random article Donate Wikipedia Wikipedia store Interaction Help About Wikipedia Community portal Recent changes Contact page Tools links here Related changes Upload file Special pages Permanent link Page information Wikidata item Cite this page In other projects Wikimedia Commons Print export Create book Download as PDF Printable version Languages Catal e tina Deutsch Espa ol Fran ais Hrvatski Italiano Latina Latvie u Lietuvi Magyar Norsk Polski Portugu s srpski Srpskohrvatski Svenska Ti ng Vi t Edit links This page was last edited on November at UTC Text available under Creative Commons Attribution ShareAlike License additional terms may apply By using this site agree Terms Use Privacy Policy Wikipedia registered trademark Wikimedia Foundation Inc non profit organization Privacy policy About Wikipedia Disclaimers Contact Wikipedia Developers Statistics Cookie statement Mobile view